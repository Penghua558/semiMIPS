$date
	Thu Sep 23 10:37:54 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module alu_tb $end
$var wire 1 ! zero $end
$var wire 1 " szero $end
$var wire 1 # soverflow $end
$var wire 1 $ snegative $end
$var wire 32 % signedout [31:0] $end
$var wire 1 & overflow $end
$var wire 32 ' out [31:0] $end
$var wire 1 ( negative $end
$var reg 32 ) A [31:0] $end
$var reg 32 * B [31:0] $end
$var reg 4 + op [3:0] $end
$var reg 32 , signedA [31:0] $end
$var reg 32 - signedB [31:0] $end
$scope module aluS $end
$var wire 32 . A [31:0] $end
$var wire 32 / B [31:0] $end
$var wire 4 0 op [3:0] $end
$var wire 32 1 signedA [31:0] $end
$var wire 32 2 signedB [31:0] $end
$var reg 1 $ negative $end
$var reg 32 3 out [31:0] $end
$var reg 1 # overflow $end
$var reg 32 4 signedout [31:0] $end
$var reg 32 5 tempout [31:0] $end
$var reg 1 " zero $end
$upscope $end
$scope module aluU $end
$var wire 32 6 A [31:0] $end
$var wire 32 7 B [31:0] $end
$var wire 4 8 op [3:0] $end
$var wire 32 9 signedA [31:0] $end
$var wire 32 : signedB [31:0] $end
$var reg 1 ( negative $end
$var reg 32 ; out [31:0] $end
$var reg 1 & overflow $end
$var reg 32 < signedout [31:0] $end
$var reg 32 = tempout [31:0] $end
$var reg 1 ! zero $end
$upscope $end
$scope task add $end
$var reg 32 > operandA [31:0] $end
$var reg 32 ? operandB [31:0] $end
$upscope $end
$scope task addu $end
$var reg 32 @ operandA [31:0] $end
$var reg 32 A operandB [31:0] $end
$upscope $end
$scope task andtask $end
$var reg 32 B operandA [31:0] $end
$var reg 32 C operandB [31:0] $end
$upscope $end
$scope task asl $end
$var reg 32 D operandA [31:0] $end
$var reg 32 E operandB [31:0] $end
$upscope $end
$scope task asr $end
$var reg 32 F operandA [31:0] $end
$var reg 32 G operandB [31:0] $end
$upscope $end
$scope task lsl $end
$var reg 32 H operandA [31:0] $end
$var reg 32 I operandB [31:0] $end
$upscope $end
$scope task lsr $end
$var reg 32 J operandA [31:0] $end
$var reg 32 K operandB [31:0] $end
$upscope $end
$scope task negation $end
$var reg 32 L operandA [31:0] $end
$upscope $end
$scope task nottask $end
$var reg 32 M operandA [31:0] $end
$upscope $end
$scope task ortask $end
$var reg 32 N operandA [31:0] $end
$var reg 32 O operandB [31:0] $end
$upscope $end
$scope task subtract $end
$var reg 32 P operandA [31:0] $end
$var reg 32 Q operandB [31:0] $end
$upscope $end
$scope task subtractu $end
$var reg 32 R operandA [31:0] $end
$var reg 32 S operandB [31:0] $end
$upscope $end
$scope task xortask $end
$var reg 32 T operandA [31:0] $end
$var reg 32 U operandB [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
x(
bx '
x&
bx %
x$
x#
x"
x!
$end
#4
0"
0$
x#
bx %
bx 3
0!
0(
0&
b10100100011101110111011101100 '
b10100100011101110111011101100 ;
b11 +
b11 0
b11 8
b10100100011100011000110011100 :
b10100100011100011000110011100 *
b10100100011100011000110011100 7
b1011110101010000 9
b1011110101010000 )
b1011110101010000 6
b10100100011100011000110011100 A
b1011110101010000 @
#8
b10100100011101110111011101100 <
b10100100011101110111011101100 '
b10100100011101110111011101100 ;
1$
b11111010010000110000110111101101 4
0#
b11111010010000110000110111101101 %
b11111010010000110000110111101101 3
b0 +
b0 0
b0 8
b11111010001000100011010110010110 2
b11111010001000100011010110010110 -
b11111010001000100011010110010110 /
b1000001101100001010111 1
b1000001101100001010111 ,
b1000001101100001010111 .
b11111010001000100011010110010110 ?
b1000001101100001010111 >
#12
b101111111101010001011000001 5
1#
1$
b101111111101010001011000001 %
b101111111101010001011000001 3
b1011001111111110 =
b1011001111111110 '
b1011001111111110 ;
b100 +
b100 0
b100 8
b10000111 :
b10000111 *
b10000111 7
b1011010010000101 9
b1011010010000101 )
b1011010010000101 6
b10000111 S
b1011010010000101 R
#16
b1011001111111110 <
b1011001111111110 '
b1011001111111110 ;
b100111011111110 4
0$
0#
b100111011111110 %
b100111011111110 3
b1 +
b1 0
b1 8
b11111111111111111001111110110011 2
b11111111111111111001111110110011 -
b11111111111111111001111110110011 /
b11111111111111111110111010110001 1
b11111111111111111110111010110001 ,
b11111111111111111110111010110001 .
b11111111111111111001111110110011 Q
b11111111111111111110111010110001 P
#20
1(
b11111111111111110100101101111011 '
b11111111111111110100101101111011 ;
1$
b11111111111111111111111111110011 %
b11111111111111111111111111110011 3
b10 +
b10 0
b10 8
b1101 1
b1101 ,
b1101 .
b1101 L
#24
0$
b10101 %
b10101 3
b11111111111111111111111111101011 1
b11111111111111111111111111101011 ,
b11111111111111111111111111101011 .
b11111111111111111111111111101011 L
#28
1"
b0 %
b0 3
b0 1
b0 ,
b0 .
b0 L
#33
1"
0(
b1000 '
b1000 ;
b101 +
b101 0
b101 8
b11000 :
b11000 *
b11000 7
b1000 9
b1000 )
b1000 6
b11000 C
b1000 B
#37
0"
b11111111111111111001111110110011 %
b11111111111111111001111110110011 3
b11111111111111111111111111111111 '
b11111111111111111111111111111111 ;
b110 +
b110 0
b110 8
b10111 :
b10111 *
b10111 7
b11111111111111111111111111101000 9
b11111111111111111111111111101000 )
b11111111111111111111111111101000 6
b10111 O
b11111111111111111111111111101000 N
#41
b11111111111111111001111110110011 %
b11111111111111111001111110110011 3
b10 '
b10 ;
b111 +
b111 0
b111 8
b111 :
b111 *
b111 7
b101 9
b101 )
b101 6
b111 U
b101 T
#45
b11111111111111111111111111111111 %
b11111111111111111111111111111111 3
b11111111111111111111111110000011 '
b11111111111111111111111110000011 ;
b1000 +
b1000 0
b1000 8
b1111100 9
b1111100 )
b1111100 6
b1111100 M
#49
b1001000 '
b1001000 ;
b11111111111111111111111110110111 9
b11111111111111111111111110110111 )
b11111111111111111111111110110111 6
b11111111111111111111111110110111 M
#53
1"
b0 %
b0 3
b1001110100 '
b1001110100 ;
b1001 +
b1001 0
b1001 8
b10 :
b10 *
b10 7
b10011101 9
b10011101 )
b10011101 6
b10 E
b10011101 D
#57
1"
b100111 '
b100111 ;
b1010 +
b1010 0
b1010 8
b10 G
b10011101 F
#61
1"
b1001110100 '
b1001110100 ;
b1011 +
b1011 0
b1011 8
b10 I
b10011101 H
#65
1"
b100111 '
b100111 ;
b1100 +
b1100 0
b1100 8
b10 K
b10011101 J
#69
b10011111 <
b10011111 '
b10011111 ;
1"
b0 4
b0 +
b0 0
b0 8
b11111111111111111111111111101001 2
b11111111111111111111111111101001 -
b11111111111111111111111111101001 /
b10111 1
b10111 ,
b10111 .
b11111111111111111111111111101001 ?
b10111 >
#73
b10011011 <
b10011011 '
b10011011 ;
1"
b1 +
b1 0
b1 8
b0 2
b0 -
b0 /
b0 1
b0 ,
b0 .
b0 Q
b0 P
#77
1"
1!
b0 '
b0 ;
b101 +
b101 0
b101 8
b110 :
b110 *
b110 7
b1001 9
b1001 )
b1001 6
b110 C
b1001 B
#81
1"
0!
1&
b10011111110010100001010110001 '
b10011111110010100001010110001 ;
b11 +
b11 0
b11 8
b100000101011011011101010100110 :
b100000101011011011101010100110 *
b100000101011011011101010100110 7
b11110011010010111000100000001011 9
b11110011010010111000100000001011 )
b11110011010010111000100000001011 6
b100000101011011011101010100110 A
b11110011010010111000100000001011 @
#85
b10011111110010100001010110001 <
0&
b10011111110010100001010110001 '
b10011111110010100001010110001 ;
0"
1$
1#
b100001011111101101111100101100 4
b100001011111101101111100101100 %
b100001011111101101111100101100 3
b0 +
b0 0
b0 8
b10000111011010110110111111100000 2
b10000111011010110110111111100000 -
b10000111011010110110111111100000 /
b10011010000100110110111101001100 1
b10011010000100110110111101001100 ,
b10011010000100110110111101001100 .
b10000111011010110110111111100000 ?
b10011010000100110110111101001100 >
#89
1(
b11010010100111011100110101100101 <
b11010010100111011100110101100101 '
b11010010100111011100110101100101 ;
b10011110000101110001111100011110 4
0$
1#
b10011110000101110001111100011110 %
b10011110000101110001111100011110 3
b1 +
b1 0
b1 8
b11000001010001101111000011100010 2
b11000001010001101111000011100010 -
b11000001010001101111000011100010 /
b1011111010111100001000000000000 1
b1011111010111100001000000000000 ,
b1011111010111100001000000000000 .
b11000001010001101111000011100010 Q
b1011111010111100001000000000000 P
#93
1$
b10011110000101110001111100011110 5
1#
b10011110000101110001111100011110 %
b10011110000101110001111100011110 3
b11100110111001100011001101111100 =
1&
1(
b11100110111001100011001101111100 '
b11100110111001100011001101111100 ;
b100 +
b100 0
b100 8
b1001010010010111100111110110100 :
b1001010010010111100111110110100 *
b1001010010010111100111110110100 7
b110001001100100000001100110000 9
b110001001100100000001100110000 )
b110001001100100000001100110000 6
b1001010010010111100111110110100 S
b110001001100100000001100110000 R
#97
